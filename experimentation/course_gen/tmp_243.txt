/Users/rahulduggal/Documents/personal_learnings/learning-assistant-v1/experimentation/new_knowledge_base/wiki/text_files/Supervised learning - Wikipedia.txt

 | Supervised learning - Wikipedia

4/9/24, 8:12 PM Supervised learning - Wikipedia

https://en.wikipedia.org/wiki/Supervised_learning 1/8

Tendency for a task to employ supervised vs.
unsupervised methods. Task names straddling
circle boundaries is intentional. It shows that the
classical division of imaginative tasks (left)
employing unsupervised methods is blurred in
today's learning schemes.

Supervised learning
Supervised learning (SL) is a paradigm in machine learning where input objects (for example, a
vector of predictor variables) and a desired output value (also known as human-labeled supervisory
signal) train a model. The training data is processed, building a function that maps new data on
expected output values.[1] An optimal scenario will allow for the algorithm to correctly determine
output values for unseen instances. This requires the learning algorithm to generalize from the
training data to unseen situations in a "reasonable" way (see inductive bias). This statistical quality of
an algorithm is measured through the so-called generalization error.

To solve a given problem of supervised learning, one
has to perform the following steps:

1. Determine the type of training examples. Before doing
anything else, the user should decide what kind of data
is to be used as a training set. In the case of
handwriting analysis, for example, this might be a
single handwritten character, an entire handwritten
word, an entire sentence of handwriting or perhaps a
full paragraph of handwriting.

2. Gather a training set. The training set needs to be
representative of the real-world use of the function.
Thus, a set of input objects is gathered and
corresponding outputs are also gathered, either from
human experts or from measurements.

3. Determine the input feature representation of the
learned function. The accuracy of the learned function
depends strongly on how the input object is

represented. Typically, the input object is transformed into a feature vector, which contains a
number of features that are descriptive of the object. The number of features should not be too
large, because of the curse of dimensionality; but should contain enough information to accurately
predict the output.

4. Determine the structure of the learned function and corresponding learning algorithm. For
example, the engineer may choose to use support-vector machines or decision trees.

5. Complete the design. Run the learning algorithm on the gathered training set. Some supervised
learning algorithms require the user to determine certain control parameters. These parameters
may be adjusted by optimizing performance on a subset (called a validation set) of the training set,
or via cross-validation.

6. Evaluate the accuracy of the learned function. After parameter adjustment and learning, the
performance of the resulting function should be measured on a test set that is separate from the
training set.

Steps to follow

Algorithm choice

https://en.wikipedia.org/wiki/File:Task-guidance.png
https://en.wikipedia.org/wiki/File:Task-guidance.png
https://en.wikipedia.org/wiki/Main_Page
https://en.wikipedia.org/wiki/Machine_learning
https://en.wikipedia.org/wiki/Inductive_bias
https://en.wikipedia.org/wiki/Generalization_error
https://en.wikipedia.org/wiki/Handwriting_analysis
https://en.wikipedia.org/wiki/Training_set
https://en.wikipedia.org/wiki/Feature_(machine_learning)
https://en.wikipedia.org/wiki/Feature_vector
https://en.wikipedia.org/wiki/Curse_of_dimensionality
https://en.wikipedia.org/wiki/Support-vector_machine
https://en.wikipedia.org/wiki/Decision_tree_learning
https://en.wikipedia.org/wiki/Hyperparameter_(machine_learning)
https://en.wikipedia.org/wiki/Validation_set
https://en.wikipedia.org/wiki/Cross-validation_(statistics)
https://en.wikipedia.org/wiki/Test_set


4/9/24, 8:12 PM Supervised learning - Wikipedia

https://en.wikipedia.org/wiki/Supervised_learning 2/8

A wide range of supervised learning algorithms are available, each with its strengths and weaknesses.
There is no single learning algorithm that works best on all supervised learning problems (see the No
free lunch theorem).

There are four major issues to consider in supervised learning:

A first issue is the tradeoff between bias and variance.[2] Imagine that we have available several
different, but equally good, training data sets. A learning algorithm is biased for a particular input  if,
when trained on each of these data sets, it is systematically incorrect when predicting the correct
output for . A learning algorithm has high variance for a particular input  if it predicts different
output values when trained on different training sets. The prediction error of a learned classifier is
related to the sum of the bias and the variance of the learning algorithm.[3] Generally, there is a
tradeoff between bias and variance. A learning algorithm with low bias must be "flexible" so that it can
fit the data well. But if the learning algorithm is too flexible, it will fit each training data set differently,
and hence have high variance. A key aspect of many supervised learning methods is that they are able
to adjust this tradeoff between bias and variance (either automatically or by providing a bias/variance
parameter that the user can adjust).

The second issue is of the amount of training data available relative to the complexity of the "true"
function (classifier or regression function). If the true function is simple, then an "inflexible" learning
algorithm with high bias and low variance will be able to learn it from a small amount of data. But if
the true function is highly complex (e.g., because it involves complex interactions among many
different input features and behaves differently in different parts of the input space), then the function
will only be able to learn with a large amount of training data paired with a "flexible" learning
algorithm with low bias and high variance.

A third issue is the dimensionality of the input space. If the input feature vectors have large
dimensions, learning the function can be difficult even if the true function only depends on a small
number of those features. This is because the many "extra" dimensions can confuse the learning
algorithm and cause it to have high variance. Hence, input data of large dimensions typically requires
tuning the classifier to have low variance and high bias. In practice, if the engineer can manually
remove irrelevant features from the input data, it will likely improve the accuracy of the learned
function. In addition, there are many algorithms for feature selection that seek to identify the relevant
features and discard the irrelevant ones. This is an instance of the more general strategy of
dimensionality reduction, which seeks to map the input data into a lower-dimensional space prior to
running the supervised learning algorithm.

Bias-variance tradeoff

Function complexity and amount of training data

Dimensionality of the input space

Noise in the output values

https://en.wikipedia.org/wiki/No_free_lunch_in_search_and_optimization
https://en.wikipedia.org/wiki/No_free_lunch_in_search_and_optimization
https://en.wikipedia.org/wiki/Feature_selection
https://en.wikipedia.org/wiki/Dimensionality_reduction


4/9/24, 8:12 PM Supervised learning - Wikipedia

https://en.wikipedia.org/wiki/Supervised_learning 3/8

A fourth issue is the degree of noise in the desired output values (the supervisory target variables). If
the desired output values are often incorrect (because of human error or sensor errors), then the
learning algorithm should not attempt to find a function that exactly matches the training examples.
Attempting to fit the data too carefully leads to overfitting. You can overfit even when there are no
measurement errors (stochastic noise) if the function you are trying to learn is too complex for your
learning model. In such a situation, the part of the target function that cannot be modeled "corrupts"
your training data - this phenomenon has been called deterministic noise. When either type of noise is
present, it is better to go with a higher bias, lower variance estimator.

In practice, there are several approaches to alleviate noise in the output values such as early stopping
to prevent overfitting as well as detecting and removing the noisy training examples prior to training
the supervised learning algorithm. There are several algorithms that identify noisy training examples
and removing the suspected noisy training examples prior to training has decreased generalization
error with statistical significance.[4][5]

Other factors to consider when choosing and applying a learning algorithm include the following:

Heterogeneity of the data. If the feature vectors include features of many different kinds (discrete,
discrete ordered, counts, continuous values), some algorithms are easier to apply than others.
Many algorithms, including support-vector machines, linear regression, logistic regression, neural
networks, and nearest neighbor methods, require that the input features be numerical and scaled
to similar ranges (e.g., to the [-1,1] interval). Methods that employ a distance function, such as
nearest neighbor methods and support-vector machines with Gaussian kernels, are particularly
sensitive to this. An advantage of decision trees is that they easily handle heterogeneous data.
Redundancy in the data. If the input features contain redundant information (e.g., highly correlated
features), some learning algorithms (e.g., linear regression, logistic regression, and distance
based methods) will perform poorly because of numerical instabilities. These problems can often
be solved by imposing some form of regularization.
Presence of interactions and non-linearities. If each of the features makes an independent
contribution to the output, then algorithms based on linear functions (e.g., linear regression,
logistic regression, support-vector machines, naive Bayes) and distance functions (e.g., nearest
neighbor methods, support-vector machines with Gaussian kernels) generally perform well.
However, if there are complex interactions among features, then algorithms such as decision trees
and neural networks work better, because they are specifically designed to discover these
interactions. Linear methods can also be applied, but the engineer must manually specify the
interactions when using them.

When considering a new application, the engineer can compare multiple learning algorithms and
experimentally determine which one works best on the problem at hand (see cross validation). Tuning
the performance of a learning algorithm can be very time-consuming. Given fixed resources, it is often
better to spend more time collecting additional training data and more informative features than it is
to spend extra time tuning the learning algorithms.

The most widely used learning algorithms are:

Support-vector machines

Other factors to consider

Algorithms

https://en.wikipedia.org/wiki/Target_variable
https://en.wikipedia.org/wiki/Overfitting
https://en.wikipedia.org/wiki/Deterministic_noise
https://en.wikipedia.org/wiki/Early_stopping
https://en.wikipedia.org/wiki/Overfitting
https://en.wikipedia.org/wiki/Anomaly_detection
https://en.wikipedia.org/wiki/Generalization_error
https://en.wikipedia.org/wiki/Generalization_error
https://en.wikipedia.org/wiki/Statistical_significance
https://en.wikipedia.org/wiki/Support_Vector_Machines
https://en.wikipedia.org/wiki/Linear_regression
https://en.wikipedia.org/wiki/Logistic_regression
https://en.wikipedia.org/wiki/Artificial_neural_network
https://en.wikipedia.org/wiki/Artificial_neural_network
https://en.wikipedia.org/wiki/K-nearest_neighbor_algorithm
https://en.wikipedia.org/wiki/K-nearest_neighbor_algorithm
https://en.wikipedia.org/wiki/Support_Vector_Machines
https://en.wikipedia.org/wiki/Decision_tree_learning
https://en.wikipedia.org/wiki/Linear_regression
https://en.wikipedia.org/wiki/Logistic_regression
https://en.wikipedia.org/wiki/K-nearest_neighbor_algorithm
https://en.wikipedia.org/wiki/K-nearest_neighbor_algorithm
https://en.wikipedia.org/wiki/Regularization_(mathematics)
https://en.wikipedia.org/wiki/Linear_regression
https://en.wikipedia.org/wiki/Logistic_regression
https://en.wikipedia.org/wiki/Support-vector_machine
https://en.wikipedia.org/wiki/Naive_Bayes_classifier
https://en.wikipedia.org/wiki/K-nearest_neighbor_algorithm
https://en.wikipedia.org/wiki/K-nearest_neighbor_algorithm
https://en.wikipedia.org/wiki/Support_Vector_Machines
https://en.wikipedia.org/wiki/Decision_tree_learning
https://en.wikipedia.org/wiki/Artificial_neural_network
https://en.wikipedia.org/wiki/Cross-validation_(statistics)
https://en.wikipedia.org/wiki/Support-vector_machine


4/9/24, 8:12 PM Supervised learning - Wikipedia

https://en.wikipedia.org/wiki/Supervised_learning 4/8

Linear regression
Logistic regression
Naive Bayes
Linear discriminant analysis
Decision trees
K-nearest neighbor algorithm
Neural networks (Multilayer perceptron)
Similarity learning

Given a set of  training examples of the form  such that  is the feature
vector of the -th example and  is its label (i.e., class), a learning algorithm seeks a function

, where  is the input space and  is the output space. The function  is an element of
some space of possible functions , usually called the hypothesis space. It is sometimes convenient to
represent  using a scoring function  such that  is defined as returning the  value
that gives the highest score: . Let  denote the space of scoring functions.

Although  and  can be any space of functions, many learning algorithms are probabilistic models
where  takes the form of a conditional probability model , or  takes the

form of a joint probability model . For example, naive Bayes and linear discriminant
analysis are joint probability models, whereas logistic regression is a conditional probability model.

There are two basic approaches to choosing  or : empirical risk minimization and structural risk
minimization.[6] Empirical risk minimization seeks the function that best fits the training data.
Structural risk minimization includes a penalty function that controls the bias/variance tradeoff.

In both cases, it is assumed that the training set consists of a sample of independent and identically
distributed pairs, . In order to measure how well a function fits the training data, a loss
function  is defined. For training example , the loss of predicting the value

 is .

The risk  of function  is defined as the expected loss of . This can be estimated from the
training data as

.

In empirical risk minimization, the supervised learning algorithm seeks the function  that minimizes
. Hence, a supervised learning algorithm can be constructed by applying an optimization

algorithm to find .

How supervised learning algorithms work

Empirical risk minimization

https://en.wikipedia.org/wiki/Linear_regression
https://en.wikipedia.org/wiki/Logistic_